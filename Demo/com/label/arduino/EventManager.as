package com.label.arduino{	import net.eriksjodin.arduino.Arduino;	import net.eriksjodin.arduino.events.ArduinoEvent;	import net.eriksjodin.arduino.events.ArduinoSysExEvent;	import flash.utils.ByteArray;	import flash.events.Event;	import flash.events.EventDispatcher;	import com.label.timesquid.*;	import com.label.arduino.sensor.IAnalogSensor;	public class EventManager extends EventDispatcher 	{		// Constants:		// Public Properties:		// Private Properties:		var a:Arduino;		var numEvents:Number = 0;		var socket:String;		var port:int = 0;		var inputPort:int = 3;				var testMode:Boolean = false;				//Analogue Sensors		var aSensors = new Object();;		private static var _instance:EventManager;				public static function getInstance()		{			if (_instance==null)			{				_instance = new EventManager();			}			return _instance;		}		/**		 * Initialise the Event Manager		 */		public function initialize(socket:String, port:int) {			this.socket = socket;			this.port = port;		}				public function registerAnalogueSensor(sensor:IAnalogSensor, port:int)		{			aSensors[port] = sensor;		}		public function setTestMode(mode:Boolean):void		{			this.testMode = mode;		}		public function connect() {			if (testMode)			{				this.addEventListener(Event.ENTER_FRAME, test);				// connect to a serial proxy on port 5331				a = new ArduinoSocketTest(this.socket,this.port);							}			else			{				// connect to a serial proxy on port 5331				a = new Arduino(this.socket,this.port);			}			// listen for connection 			a.addEventListener(Event.CONNECT,onSocketConnect);			a.addEventListener(Event.CLOSE,onSocketClose);			// listen for firmware (sent on startup)			a.addEventListener(ArduinoEvent.FIRMWARE_VERSION, onReceiveFirmwareVersion);			// listen for data			a.addEventListener(ArduinoEvent.ANALOG_DATA, onReceiveAnalogData);			//a.addEventListener(ArduinoEvent.DIGITAL_DATA, onReceiveDigitalData);			//listen for sysex messages			a.addEventListener(ArduinoSysExEvent.SYSEX_MESSAGE, onReceiveSysExMessage);					}				public function test(e:Event):void 		{			trace("T");			a.createEvents();		}		// triggered when a serial socket connection has been established		public function onSocketConnect(e:Object):void {			trace("Socket connected!");			// request the firmware version			a.requestFirmwareVersion();		}		// triggered when a serial socket connection has been closed		public function onSocketClose(e:Object):void {			trace("Socket closed!");		}		// trace out data when it arrives...		public function onReceiveAnalogData(e:ArduinoEvent):void {//			trace((numEvents++) +" Analog pin " + e.pin + " on port: " + e.port +" = " + e.value);									//Do we have a sensor registered on this event			if (aSensors[e.pin]!=null)			{				trace("Found event on pin", e.pin);				var analogSensor:IAnalogSensor = aSensors[e.pin];				trace("e.value", e.value);				analogSensor.setValue(e.value);							}						//OK We have a value, what do we do to it now		/*	if (e.pin==3)			{				targetObj.setValue(e.value);			}			if (e.pin==4)			{				targetObj2.setValue(e.value);			}			*/		}		// trace out data when it arrives...		public function onReceiveDigitalData(e:ArduinoEvent):void {			trace((numEvents++) +" Digital pin " + e.pin + " on port: " + e.port +" = " + e.value);		}		// trace incoming sysex messages		public function onReceiveSysExMessage(e:ArduinoSysExEvent) {			trace((numEvents++) +"Received SysExMessage. Command:"+e.data[0]);		}		// the firmware version is requested when the Arduino class has made a socket connection.		// when we receive this event we know that the Arduino has been successfully connected.		public function onReceiveFirmwareVersion(e:ArduinoEvent):void {			trace("Firmware version: " + e.value);			if (int(e.value) != 2) {				trace("Unexpected Firmware version encountered! This Version of as3glue was written for Firmata2.");			}			// the port value of an event can be used to determine which board the event was dispatched from			// this is one way of dealing with multiple boards, another is to add different listener methods			trace("Port: " + e.port);			// do some stuff on the Arduino...			initArduino();		}		function initArduino():void {				trace("Initializing Arduino");							// enable reporting for an analog pin			a.setAnalogPinReporting(3, Arduino.ON);			a.setAnalogPinReporting(4, Arduino.ON);			// disable reporting for an analog pin			//a.setAnalogPinReporting(3, Arduino.OFF);						// set a pin to PWM			//a.setPinMode(11, Arduino.PWM);						// write to PWM (0..255)			//a.writeAnalogPin(11, 255);						// trace out the most recently received data			//trace("Analog pin 3 is: " + a.getAnalogData(3));			//trace("Digital pin 4 is: " + a.getDigitalData(4));				// trace out the most recently received data			trace("Analog pin 3 is: " + a.getAnalogData(3));			trace("Hand (4) is: " + a.getAnalogData(4));								}	}}