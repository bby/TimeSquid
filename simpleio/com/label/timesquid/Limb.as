package com.label.timesquid{	import net.eriksjodin.arduino.Arduino;	import net.eriksjodin.arduino.events.ArduinoEvent;	import net.eriksjodin.arduino.events.ArduinoSysExEvent;	import flash.utils.ByteArray;	import flash.events.Event;	public class Limb {		// Constants:		// Public Properties:		// Private Properties:		var a:Arduino;		var numEvents:Number = 0;		var socket;		var port:int = 0;		// Initialization:		public function Limb(socket, port) {			this.socket = socket;			this.port = port;		}		// Public Methods:		// Protected Methods:		public function connect() {			// connect to a serial proxy on port 5331			a = new Arduino(socket,port);			// listen for connection 			a.addEventListener(Event.CONNECT,onSocketConnect);			a.addEventListener(Event.CLOSE,onSocketClose);			// listen for firmware (sent on startup)			a.addEventListener(ArduinoEvent.FIRMWARE_VERSION, onReceiveFirmwareVersion);			// listen for data			a.addEventListener(ArduinoEvent.ANALOG_DATA, onReceiveAnalogData);			a.addEventListener(ArduinoEvent.DIGITAL_DATA, onReceiveDigitalData);			//listen for sysex messages			a.addEventListener(ArduinoSysExEvent.SYSEX_MESSAGE, onReceiveSysExMessage);		}		// triggered when a serial socket connection has been established		function onSocketConnect(e:Object):void {			trace("Socket connected!");			// request the firmware version			a.requestFirmwareVersion();		}		// triggered when a serial socket connection has been closed		function onSocketClose(e:Object):void {			trace("Socket closed!");		}		// trace out data when it arrives...		function onReceiveAnalogData(e:ArduinoEvent):void {			trace((numEvents++) +" Analog pin " + e.pin + " on port: " + e.port +" = " + e.value);			testBlock.rotation = e.value;			testBlock.y = 200;		}		// trace out data when it arrives...		function onReceiveDigitalData(e:ArduinoEvent):void {			trace((numEvents++) +" Digital pin " + e.pin + " on port: " + e.port +" = " + e.value);		}		// trace incoming sysex messages		function onReceiveSysExMessage(e:ArduinoSysExEvent) {			trace((numEvents++) +"Received SysExMessage. Command:"+e.data[0]);		}		// the firmware version is requested when the Arduino class has made a socket connection.		// when we receive this event we know that the Arduino has been successfully connected.		function onReceiveFirmwareVersion(e:ArduinoEvent):void {			trace("Firmware version: " + e.value);			if (int(e.value) != 2) {				trace("Unexpected Firmware version encountered! This Version of as3glue was written for Firmata2.");			}			// the port value of an event can be used to determine which board the event was dispatched from			// this is one way of dealing with multiple boards, another is to add different listener methods			trace("Port: " + e.port);			// do some stuff on the Arduino...			initArduino();		}		function initArduino():void {			trace("Initializing Arduino");			// set a pin to output			//a.setPinMode(13, Arduino.OUTPUT);			// set a pin to high			//a.writeDigitalPin(13, Arduino.HIGH);			// turn on pull up on pin 4			//a.writeDigitalPin(4, Arduino.HIGH);			// set digital pin 4 to input			//a.setPinMode(4, Arduino.INPUT);			// enable reporting for digital pins			//a.enableDigitalPinReporting();			// disable reporting for digital pins			//a.disableDigitalPinReporting();			// enable reporting for an analog pin			a.setAnalogPinReporting(port, Arduino.ON);			// disable reporting for an analog pin			//a.setAnalogPinReporting(3, Arduino.OFF);			// set a pin to PWM			a.setPinMode(11, Arduino.PWM);			// write to PWM (0..255)			a.writeAnalogPin(11, 255);			// trace out the most recently received data			trace("Analog pin 3 is: " + a.getAnalogData(3));			//trace("Digital pin 4 is: " + a.getDigitalData(4));		}	}}